<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Reconocimiento de Dígitos en Castellano utilizando HTK : htk, dígitos, español, castellano, speech-recognition" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Reconocimiento de Dígitos en Castellano utilizando HTK</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/pbrusco">View on GitHub</a>

          <h1 id="project_title">Reconocimiento de Dígitos en Castellano utilizando HTK</h1>
          <h2 id="project_tagline">htk, dígitos, español, castellano, speech-recognition</h2>

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>Bienvenidos</h1>

<p>A continuación implementaremos un reconocedor de dígitos en español, más precisamente el español hablado en Argentina. Para ello utilizaremos HTK (una implementación de <a href="http://es.wikipedia.org/wiki/Modelo_oculto_de_M%C3%A1rkov">Modelos Ocultos de Markov</a>) y seguiremos los pasos recomendados en el <a href="http://htk.eng.cam.ac.uk/docs/docs.shtml">manual de HTK</a>.</p>

<p>La idea de este tutorial es que contenga todas las herramientas necesarias para implementar <strong>desde cero</strong> un programa que reconozca los números del 0 al 9. </p>

<p>Pueden ver el código completo en este <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/e393a5db8f242bb9b173f570fdd06554be5aa968/HTK/spike%20digitos?at=master">repositorio.</a></p>

<h3>Hacia dónde vamos?</h3>

<p>Queremos, a partir de grabaciones de entrada de la pinta:</p>

<p><strong>Entrada</strong>
 <img src="https://dl.dropboxusercontent.com/u/43547597/Tutorial%20HTK/12151516790.png" alt="12151516790"></p>

<p>obtener la transcripción de los dígitos, por ejemplo</p>

<p><strong>Salida</strong>
"1 2 1 5 1 5 1 6 7 9 0"</p>

<h2>Preámbulos</h2>

<p>La tarea de reconocimiento del habla (speech recognition) es una tarea difícil. La mayor dificultad está en la enorme cantidad de variaciones al analizar una palabra dicha por dos personas distintas, a través de dos canales distintos (estudio radial vs. teléfono), en situaciones distintas, con distintas emociones, por dos personas que hablan el mismo idioma pero de distintos orígenes, etc. E incluso, una misma persona intentando reproducir lo que dijo, nunca puede hacerlo exactamente igual. </p>

<p>Esto implica, que la tarea de hacer que una maquina reconozca el habla incluye facilitarle datos de entrenamiento suficientes y buenos algoritmos para normalizar la señal acústica. </p>

<p>Algunos de los métodos más utilizados en los últimos años están basados en "Hidden Markov Models" (HMMs), modelos formales probabilísticos que hablan sobre probabilidades de, por ejemplo, que cierto fonema sea dicho de una u otra manera, o que luego de cierta parte de un fonema continúe alguna otra parte, etc.
Luego, se combina esta técnica con otras como una que permite normalizar las señales sonoras extrayendo su esencia, una de las técnicas más utilizadas es la que consta de extraer los llamados <a href="http://es.wikipedia.org/wiki/MFCC">Mel Frecuency Ceptral Coefficients (MFCCs)</a> y luego, por ejemplo, utilizando <a href="http://en.wikipedia.org/wiki/Mixture_model#Gaussian_mixture_model">Gaussian Mixture Models (GMMs)</a>, se consigue finalmente que se pueda comparar palabras habladas a pesar de sus variaciones esperables. </p>

<p>Existen varios sistemas (o toolkits) que implementan y facilitan la interacción y entrenamiento de HMMs. En este tutorial utilizaremos <a href="http://htk.eng.cam.ac.uk">The Hidden Markov Model Toolkit (HTK)</a>. </p>

<h2>Preparando el entorno</h2>

<h3>Software</h3>

<p>La forma de instalar el software necesario depende de nuestro sistema operativo, aquí mostraremos como lograrlo en Ubuntu y Mac OS X.</p>

<p>Para poder generar nuestro reconocedor, primero debemos descargar <a href="http://htk.eng.cam.ac.uk/download.shtml">HTK</a>, luego, dentro de la carpeta descargada: </p>

<pre><code> ./configure
make all
sudo make install
</code></pre>

<p><strong>HTK en Ubuntu</strong></p>

<p>Ante algún problema, ejecutar:</p>

<pre><code>sudo apt-get install gcc-multilib
sudo apt-get install libx11-dev
./configure --disable-hslab (por un error -lX11) 
</code></pre>

<p>(si fue necesario realizar el ultimo paso, no dispondremos de la herramienta HSLab, reemplazable por, por ejemplo, audacity)</p>

<p><strong>HTK en MAC (Mountain Lion)</strong></p>

<p>Ante algún problema, asegurarse de tener instalado:</p>

<ul>
<li>
<a href="http://xquartz.macosforge.org/landing/">XQuartz</a> (del cual necesitamos X11)</li>
<li>gcc, disponible con los <a href="http://www.programadorfreelanceargentina.com/2012/05/como-instalar-xcode-command-line-tools.html">Command Line Tools</a> de XCode </li>
</ul><p>Si el problema persiste, agregar <code>-I/usr/X11R6/include</code> en los cflags de los makefiles que estan, en el directorio de htk y en htklib, (información sacada de esta <a href="http://aidiary.hatenablog.com/entry/20130113/1358046622">página</a>, para leerla, traducir usando el traductor de google por ejemplo y tener cuidado que los comandos también se traducen). </p>

<p><strong>Ruby</strong></p>

<p>Además de HTK, recomiendo tener instalado <a href="http://www.ruby-lang.org/es/downloads/">Ruby</a> (para ciertos scripts .rb) </p>

<h3>Organización del código</h3>

<p>Para lograr hacer funcionar el programa, deberemos fijar la ubicación de cada uno de los archivos que creemos, recomiendo utilizar la misma estructura que yo utilizo ya que los comandos están preparados para estas rutas. Por supuesto, al ir entendiendo cada uno de los comandos y scripts, los archivos podrán ser movidos a donde el que los utilice considere.</p>

<p><a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/code_organization.txt?at=master">Aquí</a> podrán encontrar una posible organización y es en la cual me basaré a partir de ahora. La idea no es intentar entenderla desde un principio, sino consultarla cuando se tiene alguna duda. </p>

<h3>Sobre el formato de los archivos</h3>

<p>Una aclaración que puede ahorrarles horas de errores incomprensibles. En <strong>TODOS</strong> los archivos que se utilicen en los comandos de HTK, chequeen que siempre haya un "enter" al final (y que se encuentre en formato unix, opción disponible si usan <a href="http://www.sublimetext.com/">Sublime</a> en View - Line Endings - Unix por ejemplo)</p>

<hr><h1>Implementación</h1>

<h2>1. Preparando los datos</h2>

<p>En esta sección generaremos la gramática, los listados y el diccionario base para comenzar a trabajar. Por otro lado, debemos conseguir (o grabar) los archivos de audio que usaremos para entrenar al sistema. </p>

<h3>1.1. Gramática</h3>

<p>Para que nuestro programa entienda palabras, lo primero que debemos indicarle es que forma pueden tener las oraciones que grabemos.</p>

<p>Dado que en nuestro caso queremos reconocer dígitos, lo haremos con la siguiente grámatica:</p>

<pre><code>$digito = UNO | DOS | TRES | CUATRO | CINCO | SEIS | SIETE | OCHO | NUEVE | CERO;
( SENT-START ( &lt;$digito&gt; ) SENT-END )
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Dictionary/DictionarySources/grammar?at=master">Dictionary/DictionarySources/grammar</a></p>

<p>Más info sobre el <a href="http://www.ee.columbia.edu/ln/LabROSA/doc/HTKBook21/node131.html">lenguaje utilizado</a></p>

<p>Básicamente, se indica a través de este archivo, que las grabaciones tendrán dígitos (uno o más). </p>

<h3>1.2. Listado de palabras</h3>

<p>En este paso debemos listar todas las posibles palabras de nuestra gramática (ordenadas alfabeticamente). Para ello, podemos listarlas y luego aplicar el comando "sort" de unix. </p>

<pre><code>CERO
CINCO
CUATRO
DOS
NUEVE
OCHO
SEIS
SENT-END
SENT-START
SIETE
TRES
UNO
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Dictionary/DictionarySources/words-sorted.list?at=master">Dictionary/DictionarySources/words-sorted.list</a></p>

<h3>1.3. Diccionario de fonemas</h3>

<p>Este paso es importante e indica que fonemas utilizaremos para describir cada palabra, aquí es donde, el español hablado en España varía del hablado en Argentina, por ejemplo, la palabra "cero" puede tener las siguientes transcripciones a fonemas respectivamente.
<code>CERO th e r o</code> o <code>CERO s e r o</code></p>

<p>Ya que utilizaremos castellano, el diccionario tendrá la siguiente pinta:</p>

<pre><code>CERO s e r o sp
CINCO s i n c o sp
CUATRO k u a t r o sp
DOS d o s sp
NUEVE n u e b e sp
OCHO o ch o sp
SEIS s e i s sp
SENT-END sil
SENT-START sil
SIETE s i e t e sp
TRES t r e s sp
UNO u n o sp
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Dictionary/DictionarySources/dict?at=master">Dictionary/DictionarySources/dict</a></p>

<p>(notar que se agrega una pausa corta "sp" al final de cada palabra y que debe contenter SENT-START y SENT-END con "sil" para poder funcionar)</p>

<h3>1.4. Grabando datos de entrenamiento</h3>

<p>Para poder entrenar nuestro sistema, se necesitan grabaciones de entrenamiento, la decisión sobre que datos de entrenamiento usar implican un mejor o peor desempeño en el reconocedor. Para esta prueba en particular, se grabaron 4 sets de entrenamiento (train1, train2, train3 y train4) en dónde cada uno contiene una grabación por cada dígito (de manera aislada, es decir, solo el dígito de comienzo a fin sin silencios). </p>

<p>Ejemplo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Data/Recorded/waves/train/train1/seis.wav?at=master">Data/Recorded/waves/train/train1/seis.wav</a></p>

<p>Para lograr compatibilidad con HTK, usaremos el siguiente formato para grabar (entre paréntesis indico donde encontrar la opción si utilizamos Audacity 2.0.3):</p>

<ul>
<li>Mono (Edit\Preferences\Devices) </li>
<li>16 kHz sampling frequency (Edit\Preferences\Quality\Sampling) </li>
<li>16 bits por sample (Edit\Preferences\Quality\Sampling) </li>
</ul><p>Por otro lado, cada uno de estos datos de entrenamiento necesitan una transcripción (.lab), esta transcripción debe contener los fonemas que se utilizan en la palabra grabada. </p>

<p>En vez de hacerlo manualmente, aprovecharemos un script que se encargará de facilitarnos ese trabajo, pero en caso de no tener este script, habría que construirlos manualmente con la pinta:</p>

<pre><code>0.0 0.5064375  o ch o
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Data/Train/train1-ocho.lab?at=master">Data/Train/train1-ocho.lab</a></p>

<p>El script que utilizaremos es <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Helpers/labels_from_wavs_script.rb?at=master">Helpers/labels_from_wavs_script.rb</a></p>

<pre><code>sudo gem install waveinfo
irb Helpers/labels_from_wavs_script.rb "Data/Recorded/waves/train/" "Data/Train/"
</code></pre>

<p>Este scipt escanea la carpeta de origen (Data/Recorded/waves/train) en búsqueda de subcarpetas que contengan wavs. Al encontrarlos, genera un archivo .lab por cada .wav (si no existe previamente en la carpeta de origen) y los guarda en el la carpeta de destino (segundo parametro) "Data/Train/" con el nombre "subcarpeta"-"nombre".lab (ejemplo el archivo train1-ocho.lab mostrado anteriormente).
Si existía un .lab en alguna de las subcarpetas del origen (ver <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Data/Recorded/waves/train/train5?at=master">train5</a> por ejemplo) el script copia estas transcripciones agregándoles en el nombre, el prefijo de la subcarpeta correspondiente. Se puede ver un ejemplo de este caso en <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Data/Train/train5-siete.lab?at=master">Data/Train/train5-siete</a>, notar que el .lab no fue generado automaticamente sino copiado de la carpeta train5. </p>

<h2>2. Combinando los datos</h2>

<p>En esta sección, nos concentraremos en dejar todo listo para empezar con el entrenamiento. Generaremos un diccionario y listado de fonemas, convertiremos la gramática a un formato estándar, crearemos Master Label Files, convertiremos el audio a su vector de features (MFCCs), y crearemos las carpetas necesarias para almacenar los distintos modelos que irán avanzando a medida que avance el entrenamiento. </p>

<h3>2.1. Diccionario y listado de fonemas</h3>

<p>Para generar el diccionario y listado de fonemas que utilizaremos más adelante, usaremos el comando HDMan de HTK: </p>

<pre><code>HDMan -m -w Dictionary/DictionarySources/words-sorted.list -n Dictionary/phones-with-sp.list -l dlog Dictionary/phones.dict Dictionary/DictionarySources/dict
</code></pre>

<p>Esto último, genera 2 archivos importantes: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Dictionary/phones.dict?at=master">Dictionary/phones.dict</a> y <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Dictionary/phones-with-sp.list?at=master">Dictionary/phones-with-sp.list</a>, y por otro lado, un log (dlog) que sirve para ver cuantas repeticiones de los fonemas se utilizan. </p>

<p>Podrán notar que phones.dict y DictionarySources/dict son muy parecidos (o iguales en este caso), la razón para que esto ocurra es que dict es usado como source para generar phones.dict, y solo se toma de él las palabras que aparecen en word-sorted.list. Es decir, sería totalmente posible tener un diccionario dict con muchas más traducciones palabra-fonemas como source. </p>

<p>Luego, debemos crear un nuevo archivo copiando Dictionary/phones-with-sp.list en el cual borremos la linea que contiene al fonema "sp", generando así el archivo <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Dictionary/phones.list?at=master">Dictionary/phones.list</a></p>

<h3>2.2. Gramática a WordNet</h3>

<p>HTK utiliza un formato especial para representar la gramática, es un "word network" (red de palabras), básicamente, es una notación de bajo nivel llamada "HTK Standard Lattice Format (SLF)" en el cual, cada instancia de palabra y cada transición entre palabras esta listado explicitamente. Podemos crear esta red automaticamente utilizando el comando</p>

<pre><code>HParse Dictionary/DictionarySources/grammar Dictionary/DictionarySources/grammar.wordnet 
</code></pre>

<p>Aclaración: Este comando es el único que no logré hacer funcionar en Mac OS X, así que opté por correrlo en Ubuntu donde no hubo problemas. </p>

<h3>2.3. Master label files (mlf)</h3>

<p>A continuación crearemos una version "naive" de un master label file, y digo "naive" porque no explota el verdadero poder de estos archivos, que permiten, entre otras cosas, una organización más inteligente de labels y grabaciones de entrenamiento. </p>

<p>Primero, crearemos el archivo "MFCCs words.mlf"</p>

<pre><code>irb Helpers/generate_mfccs_from_training.rb
</code></pre>

<p>Esto genera un archivo de la pinta</p>

<pre><code>#!MLF!#
"*/train1-cero.lab"
CERO
.
"*/train1-cinco.lab"
CINCO
.
"*/train1-cuatro.lab"
CUATRO
.
"*/train1-dos.lab"
DOS
.
"*/train1-uno.lab"
UNO
.
"*/train2-cero.lab"
CERO
.
"*/train2-cinco.lab"
CINCO
.
"*/train2-cuatro.lab"
...
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Data/train%20MFCCs-words.mlf?at=master">Data/train MFCCs-words.mlf</a></p>

<p>Luego asegurarse que cada elemento contenga la transcripción a nivel palabras de lo que cada .wav contiene (el script lo hace en base al nombre del archivo). </p>

<p>Luego debemos generar un archivo que contiene las transcripciones a nivel fonemas, para eso utilizaremos el comando: </p>

<pre><code>HLEd -l ’*’ -d Dictionary/phones.dict -i Data/train\ MFCCs-phones.mlf Configs/HLEd.config Data/train\ MFCCs-words.mlf
</code></pre>

<p>Que genera un archivo de la pinta:</p>

<pre><code>#!MLF!#
"’*’/train1-cero.lab"
sil
s
e
r
o
sil
.
"’*’/train1-cinco.lab"
sil
s
i
n
c
o
sil
.
"’*’/train1-cuatro.lab"
sil
k
u
a
t
r
o
sil
.
...
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Data/train%20MFCCs-phones.mlf?at=master">Data/train MFCCs-phones.mlf</a></p>

<h3>Mel Frequency Cepstral Coefficients (MFCCs)</h3>

<p>Para traducir los .wav al formato de features que utilizaremos (MFCCs), vamos a usar el comando <em>HCopy</em></p>

<p>Primero, necesitamos generar ciertos archivos llamados <em>scripts</em> en el manual de HTK, que constan, generalmente, de listados de archivos que los comandos luego recorrerán y tomarán como input. </p>

<p>Por ejemplo, antes de correr el comando HCopy, utilizaremos el siguiente comando</p>

<pre><code>irb Helpers/generate_hcopy_script.rb
</code></pre>

<p>Este comando, crea un archivo de la pinta:</p>

<pre><code>./Data/Recorded/waves/train/train1/cero.wav  ./Data/Train/train1-cero.mfc 
./Data/Recorded/waves/train/train1/cinco.wav  ./Data/Train/train1-cinco.mfc 
./Data/Recorded/waves/train/train1/cuatro.wav  ./Data/Train/train1-cuatro.mfc 
./Data/Recorded/waves/train/train1/dos.wav  ./Data/Train/train1-dos.mfc 
./Data/Recorded/waves/train/train1/nueve.wav  ./Data/Train/train1-nueve.mfc 
./Data/Recorded/waves/train/train1/ocho.wav  ./Data/Train/train1-ocho.mfc 
./Data/Recorded/waves/train/train1/seis.wav  ./Data/Train/train1-seis.mfc 
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Scripts/HCopy.script?at=master">Scripts/HCopy.script</a></p>

<p>Luego, necesitamos generar el archivo de configuración HCopy.config</p>

<pre><code># Coding parameters
SOURCEKIND = WAVEFORM
SOURCEFORMAT = WAV
TARGETKIND = MFCC_0
TARGETRATE = 100000.0
SAVECOMPRESSED = T
SAVEWITHCRC = T
WINDOWSIZE = 250000.0
USEHAMMING = T
PREEMCOEF = 0.97
NUMCHANS = 26
CEPLIFTER = 22
NUMCEPS = 12
ENORMALISE = F

</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Configs/HCopy.config?at=master">Configs/HCopy.config</a></p>

<p>Finalmente, podemos correr HCopy para traducir de wavs a mfccs: </p>

<pre><code>HCopy -T 1 -C Configs/HCopy.config -S Scripts/HCopy.script
</code></pre>

<p>Si todo salió bien, deberíamos tener la carpeta <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/HTK/spike%20digitos/Data/Train?at=master">Data/Train</a> lleno de archivos .mfc (uno por cada grabación de entrenamiento)</p>

<h3>2.4. Preparando la estructura para el modelo</h3>

<p>Ahora necesitamos crear una serie de carpetas para poder almacenar los modelos, podemos usar el siguiente comando Bash:</p>

<pre><code>for NUMBER in {0..9}
do
  mkdir Models/hmm$NUMBER
done
</code></pre>

<h3>2.5. Listado de archivos de entrenamiento para HCompV</h3>

<p>Para generar HCompV.script:</p>

<pre><code>irb Helpers/generate_hcompv_script.rb
</code></pre>

<h2>3. Entrenamiento del modelo</h2>

<h3>3.1. Hmm0 - Hmm3</h3>

<p>Primer modelo prototípico:</p>

<pre><code>  ~o &lt;VecSize&gt; 39 &lt;MFCC_0_D_A&gt;  
  ~h "prototype"
&lt;BeginHMM&gt;
  &lt;NumStates&gt; 5
  &lt;State&gt; 2 
    &lt;Mean&gt; 39
      0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
    &lt;Variance&gt; 39
      1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
  &lt;State&gt; 3
    &lt;Mean&gt; 39
      0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
    &lt;Variance&gt; 39
      1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
  &lt;State&gt; 4
    &lt;Mean&gt; 39
      0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
    &lt;Variance&gt; 39
      1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
  &lt;TransP&gt; 5
   0.000e+0   1.000e+0   0.000e+0   0.000e+0   0.000e+0
   0.000e+0   6.000e-1   4.000e-1   0.000e+0   0.000e+0
   0.000e+0   0.000e+0   6.000e-1   4.000e-1   0.000e+0
   0.000e+0   0.000e+0   0.000e+0   6.000e-1   4.000e-1
   0.000e+0   0.000e+0   0.000e+0   0.000e+0   0.000e+0
&lt;EndHMM&gt;

</code></pre>

<p>Primer paso, modelo prototípico a la carpeta hmm0</p>

<p>Nuevamente necesitamos el archivo de configuración correspondiente:</p>

<pre><code>HCompV.config
</code></pre>

<p>Ahora si, </p>

<pre><code>HCompV -C Configs/HCompV.config -f 0.01 -m -S Scripts/HCompV.script -M Models/hmm0 Models/prototype
</code></pre>

<ul>
<li>Copiar el prototipo en hmmdefs (uno por cada fonema, utilizando phones.list)</li>
<li>Copiar vFloors a macros agregando el header</li>
</ul><p>Generar el script para HERest</p>

<pre><code>irb Helpers/generate_herest_script.rb
</code></pre>

<p>Re-estimar usando la herramienta para "embedded re-estimation" HERest</p>

<pre><code>HERest -T 1 -C Configs/HERest.config -I Data/train\ MFCCs-phones.mlf -t 1000.0 1000.0 10000.0 -S Scripts/HERest.script -H Models/hmm0/macros -H Models/hmm0/hmmdefs -M Models/hmm1 Dictionary/phones.list
HERest -T 1 -C Configs/HERest.config -I Data/train\ MFCCs-phones.mlf -t 1000.0 1000.0 10000.0 -S Scripts/HERest.script -H Models/hmm1/macros -H Models/hmm1/hmmdefs -M Models/hmm2 Dictionary/phones.list
HERest -T 1 -C Configs/HERest.config -I Data/train\ MFCCs-phones.mlf -t 1000.0 1000.0 10000.0 -S Scripts/HERest.script -H Models/hmm2/macros -H Models/hmm2/hmmdefs -M Models/hmm3 Dictionary/phones.list
</code></pre>

<h3>3.2. Hmm4 - Hmm7</h3>

<p>Agregar el estado "sp" en una copia de hmmdefs de hmm3 y guardarlo en hmm4. Para agregar el estado, hacer lo siguiente:
<a href="http://www.voxforge.org/home/dev/acousticmodels/linux/create/htkjulius/tutorial/monophones/step-7">agregar sp</a></p>

<pre><code>HHEd -A -D -T 1 -H Models/hmm4/macros -H Models/hmm4/hmmdefs -M Models/hmm5 Configs/HHEd.config Dictionary/phones-with-sp.list
</code></pre>

<pre><code>HERest -T 1 -C Configs/HERest.config -I Data/train\ MFCCs-phones.mlf -t 1000.0 1000.0 10000.0 -S Scripts/HERest.script -H Models/hmm5/macros -H Models/hmm5/hmmdefs -M Models/hmm6 Dictionary/phones-with-sp.list
HERest -T 1 -C Configs/HERest.config -I Data/train\ MFCCs-phones.mlf -t 1000.0 1000.0 10000.0 -S Scripts/HERest.script -H Models/hmm6/macros -H Models/hmm6/hmmdefs -M Models/hmm7 Dictionary/phones-with-sp.list
</code></pre>

<h2>4. Resultados</h2>

<h3>4.1. Grabar datos para testear</h3>

<h3>4.2. Generar vectores MFCC</h3>

<p>Generar los MFCCs de los datos de testeo</p>

<pre><code>HCopy -T 1 -C Configs/HCopyTests.config -S Scripts/HCopyTests.script
</code></pre>

<h3>Obtener resultados</h3>

<p>Resultados: </p>

<pre><code>HVite -H Models/hmm7/macros -H Models/hmm7/hmmdefs -S Scripts/HVite.script -l ’*’ -i recout.mlf -w Dictionary/DictionarySources/grammar.wordnet -p 0.0 -s 5.0 Dictionary/phones.dict Dictionary/phones-with-sp.list
</code></pre>

<h3>4.3. Obtener resultados en vivo</h3>

<p>Resultados en vivo:</p>

<pre><code>HVite -H Models/hmm7/macros -H Models/hmm7/hmmdefs -C Configs/Live.config -w Dictionary/DictionarySources/grammar.wordnet -p 0.0 -s 5.0 Dictionary/phones.dict Dictionary/phones-with-sp.list
</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
