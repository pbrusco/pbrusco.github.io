<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Reconocimiento de Dígitos en Castellano utilizando HTK : htk, reconocimiento de dígitos, español, castellano, speech-recognition, machine learning" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/bootstrap.css">
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">
    <link rel="stylesheet" type="text/css" media="screen" href="http://code.jquery.com/ui/1.10.2/themes/smoothness/jquery-ui.css">
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/jquery.tocify.css">
    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/custom.css">


    <script src="http://code.jquery.com/jquery-1.9.1.min.js"></script>
    <script src="http://code.jquery.com/ui/1.10.2/jquery-ui.js"></script>
    <script src="javascripts/jquery.tocify.min.js"></script>
    <script src="javascripts/bootstrap.js"></script>
    <script>
      function render_extern_code(){
        $( "includecode" ).each(function( code ) {
          var name = $(this).attr('name');
          var id = $(this).attr('id');
          var elem = $(this)
          $.ajax({                                                                                      
            url: "http://jsonpify.heroku.com?resource=https://bitbucket.org/pbrusco/tesis-proyectos/raw/master/Spikes/digitos/"+name,  
            dataType: 'jsonp',                                                                          
            success: function(data){                                                                    
              elem.replaceWith('<pre><code>'+ data + '</code></pre> <p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/'+name+'?at=master">'+name+'</a></p>');
            }                                                                                           
          });
        });
      }
    </script>
    <script>
      $(function() {
        $("#toc").tocify({ selectors: "h1,h2,h3", showAndHide: true, extendPage: false});
        //Calls the tocify method on your HTML div.
        $("#toc").affix({offset: 300});
       
        render_extern_code();
       });
    </script>

    <div id="fb-root"></div>
    <script>(function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) return;
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/es_LA/all.js#xfbml=1&appId=182474068506880";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));</script>

    <title>Reconocimiento de Dígitos en Castellano utilizando HTK</title>
  </head>

  <body>
    <!-- HEADER -->

    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/pbrusco">View on GitHub</a>

          <h2 id="project_title">Reconocimiento de Dígitos en Castellano utilizando HTK</h2>
          <br/><span id="project_tagline">htk, reconocimiento de dígitos, español, castellano, speech-recognition, machine learning</span>
          

        </header>
    </div>


    <!-- MAIN CONTENT -->

    <div id="main_content_wrap" class="outer">
      <div id="toc"></div>
      <section id="main_content" class="inner">
        <h1 style="margin-top:0px !important">Bienvenidos</h1>


<p>A continuación implementaremos un (simple) reconocedor de dígitos en español, más precisamente el español hablado en Argentina. Para ello utilizaremos HTK (una implementación de <a href="http://es.wikipedia.org/wiki/Modelo_oculto_de_M%C3%A1rkov">Modelos Ocultos de Markov</a>) y seguiremos los pasos recomendados en el <a href="http://htk.eng.cam.ac.uk/docs/docs.shtml">manual de HTK</a>.</p>

<p>La idea de este tutorial es que contenga todas las herramientas necesarias para implementar <strong>desde cero</strong> un programa que reconozca los números del 0 al 9 utilizando un subconjunto de las posiblidades que brinda HTK. </p>

<p>Pueden ver el código completo en este <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos?at=master">repositorio.</a></p>

<h3>Hacia dónde vamos?</h3>

<p>Queremos, a partir de grabaciones de entrada de la pinta:</p>

<p><strong>Entrada</strong>
 <img src="https://dl.dropboxusercontent.com/u/43547597/Tutorial%20HTK/12151516790.png" alt="12151516790"></p>

<p>obtener la transcripción de los dígitos, por ejemplo</p>

<p><strong>Salida</strong>
<pre>
0 t1 UNO 
t1 t2 DOS 
t2 t3 UNO 
t3 t4 CINCO 
t4 t5 UNO 
t5 t6 CINCO 
t6 t7 UNO 
t7 t8 SEIS 
t8 t9 SIETE 
t9 t10 NUEVE 
t10 t11 CERO
</pre>
</p>

<h2>Preámbulos</h2>

<p>La tarea de reconocimiento del habla (speech recognition) es una tarea difícil. La mayor dificultad está en la enorme cantidad de variaciones al analizar una palabra dicha por dos personas distintas, a través de dos canales distintos (estudio radial vs. teléfono), en situaciones distintas, con distintas emociones, por dos personas que hablan el mismo idioma pero de distintos orígenes, etc. E incluso, una misma persona intentando reproducir lo que dijo, nunca puede hacerlo exactamente igual. </p>

<p>Esto implica, que la tarea de hacer que una maquina reconozca el habla incluye facilitarle datos de entrenamiento suficientes y buenos algoritmos para normalizar la señal acústica. </p>

<p>Algunos de los métodos más utilizados en los últimos años están basados en "Hidden Markov Models" (HMMs), modelos formales probabilísticos que hablan sobre probabilidades de, por ejemplo, que cierto fonema sea dicho de una u otra manera, o que luego de cierta parte de un fonema continúe alguna otra parte, etc.
Luego, se combina esta técnica con otras como una que permite normalizar las señales sonoras extrayendo su esencia, una de las técnicas más utilizadas es la que consta de extraer los llamados <a href="http://es.wikipedia.org/wiki/MFCC">Mel Frecuency Ceptral Coefficients (MFCCs)</a> y luego, por ejemplo, utilizando <a href="http://en.wikipedia.org/wiki/Mixture_model#Gaussian_mixture_model">Gaussian Mixture Models (GMMs)</a>, se consigue finalmente que se pueda comparar palabras habladas a pesar de sus variaciones esperables. </p>

<p>Existen varios sistemas (o toolkits) que implementan y facilitan la interacción y entrenamiento de HMMs. En este tutorial utilizaremos <a href="http://htk.eng.cam.ac.uk">The Hidden Markov Model Toolkit (HTK)</a>. </p>

<h2>Preparando el entorno</h2>

<h3>Software</h3>

<p>La forma de instalar el software necesario depende de nuestro sistema operativo, aquí mostraremos como lograrlo en Ubuntu y Mac OS X.</p>

<p>Para poder generar nuestro reconocedor, primero debemos descargar <a href="http://htk.eng.cam.ac.uk/download.shtml">HTK</a>, luego, dentro de la carpeta descargada: </p>

<pre><code> ./configure
make all
sudo make install
</code></pre>

<p><strong>HTK en Ubuntu</strong></p>

<p>Ante algún problema, ejecutar:</p>

<pre><code>sudo apt-get install gcc-multilib
sudo apt-get install libx11-dev
./configure --disable-hslab (por un error -lX11) 
sudo apt-get install libc6-dev-i386 
sudo apt-get install libx11-dev:i386
</code></pre>

<p>(si fue necesario realizar el ultimo paso, no dispondremos de la herramienta HSLab, reemplazable por, por ejemplo, audacity)</p>

<p><strong>HTK en MAC (Mountain Lion)</strong></p>

<p>Ante algún problema, asegurarse de tener instalado:</p>

<ul>
<li>
<a href="http://xquartz.macosforge.org/landing/">XQuartz</a> (del cual necesitamos X11)</li>
<li>gcc, disponible con los <a href="http://www.programadorfreelanceargentina.com/2012/05/como-instalar-xcode-command-line-tools.html">Command Line Tools</a> de XCode </li>
</ul><p>Si el problema persiste, agregar <code>-I/usr/X11R6/include</code> en los cflags de los makefiles que estan, en el directorio de htk y en htklib, (información sacada de esta <a href="http://aidiary.hatenablog.com/entry/20130113/1358046622">página</a>, para leerla, traducir usando el traductor de google por ejemplo y tener cuidado que los comandos también se traducen). </p>

<p><strong>Ruby</strong></p>

<p>Además de HTK, recomiendo tener instalado <a href="http://www.ruby-lang.org/es/downloads/">Ruby</a> (para ciertos scripts .rb) y <a href="http://rubygems.org/pages/download">RubyGems</a></p>

<p><strong>Aclaración importante</strong> Todos los scripts hechos en ruby, son simplemente automatizaciones de procesos que se pueden hacer tranquilamente a mano e incluso, la mayoría necesitan de un simple editor de texto. Recomiendo intentar realizar a mano el proceso antes (o incluso después) de correr los .rb para entender que funcionalidad aplican.</p>

<h3>Organización del código</h3>

<p>Para lograr hacer funcionar el programa, deberemos fijar la ubicación de cada uno de los archivos que creemos, recomiendo utilizar la misma estructura que yo utilizo ya que los comandos están preparados para estas rutas. Por supuesto, al ir entendiendo cada uno de los comandos y scripts, los archivos podrán ser movidos a donde el que los utilice considere.</p>

<p><a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/code_organization.txt?at=master">Aquí</a> podrán encontrar una posible organización y es en la cual me basaré a partir de ahora. La idea no es intentar entenderla desde un principio, sino consultarla cuando se tiene alguna duda. </p>

<p>Les dejo también un script para crear la estructura troncal en cualquier sistema con Unix que contiene los scripts de ruby que utilizaremos <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/create_structure.sh">create_structure.sh</a> y luego llenar la carpeta Helpers con los estos <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Helpers?at=master">archivos</a>. La forma de correrlo es, copiando el contenido del archivo en una consola, o, al bajar el archivo, ejecutar <code>./create_structure.sh</code>.</p>

<p>Recomiendo también, utilizar un buen sistema de control de versiones (git, hg, svn, etc) para hacer commits ante cada paso logrado y así estar más preparados ante un olvido o un error en el proceso. </p>

<p>Listo, con la estructura creada, podemos empezar a trabajar en nuestro reconocedor.</p>

<h3>Sobre el formato de los archivos</h3>

<p>Una aclaración que puede ahorrarles horas de errores incomprensibles. En <strong>TODOS</strong> los archivos que se utilicen en los comandos de HTK, chequeen que siempre haya un "enter" al final (y que se encuentre en formato unix, opción disponible si usan <a href="http://www.sublimetext.com/">Sublime</a> en View - Line Endings - Unix por ejemplo)</p>

<h1>Implementación</h1>

<h2>0. Idea general</h2>

<p>La implementación de este reconocedor constará de 4 pasos esenciales:</p>

<ul>
<li>Preparación de datos</li>
<li>Combinación de datos</li>
<li>Entrenamiento del modelo</li>
<li>Generación de resultados</li>
</ul><p>En los primeros dos pasos, generaremos los archivos necesarios para definir que tipo y de que manera reconoceremos palabras en el sistema (gramática, diccionario, listados de palabras). Luego, grabaremos el audio necesario para el entrenamiento y lo convertiremos a un formato aceptable para los modelos (de .wav a MFCCs) mientras preparamos un modelo prototipo que utilizaremos en los siguientes pasos.</p>

<p>En el tercer paso, nos concentraremos en entrenar y pulir los modelos que van a servir para reconocer las grabaciones de prueba, es decir, entrenar los HMMs puliendo las distribuciones probabilísticas asociadas a los distintos estados. </p>

<p>Finalmente, en el cuarto paso, grabaremos datos de prueba y los utilizaremos para ver que tan buena fue nuestra aproximación a lo que uno espera de un reconocedor de palabras.</p>

<h2>1. Preparando los datos</h2>

<p>En esta sección generaremos la gramática, los listados y el diccionario base para comenzar a trabajar. Por otro lado, debemos conseguir (o grabar) los archivos de audio que usaremos para entrenar al sistema. </p>

<h3>1.1. Gramática</h3>

<p>Para que nuestro programa entienda palabras, lo primero que debemos indicarle es que forma pueden tener las oraciones que grabemos.</p>

<p>Dado que en nuestro caso queremos reconocer dígitos, lo haremos con la siguiente grámatica:</p>

<includecode id="grammar" name="Dictionary/DictionarySources/grammar"></includecode>


<p>Más info sobre el <a href="http://www.ee.columbia.edu/ln/LabROSA/doc/HTKBook21/node131.html">lenguaje utilizado</a></p>

<p>Básicamente, se indica a través de este archivo, que las grabaciones tendrán dígitos (uno o más). </p>

<h3>1.2. Listado de palabras</h3>

<p>En este paso debemos listar todas las posibles palabras de nuestra gramática (ordenadas alfabeticamente). Para ello, podemos listarlas y luego aplicar el comando "sort" de unix. </p>

<pre><code>CERO
CINCO
CUATRO
DOS
NUEVE
OCHO
SEIS
SIETE
TRES
UNO
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Dictionary/DictionarySources/words-sorted.list?at=master">Dictionary/DictionarySources/words-sorted.list</a></p>

<h3>1.3. Diccionario de fonemas</h3>

<p>Este paso es importante e indica que fonemas utilizaremos para describir cada palabra, aquí es donde, el español hablado en España varía del hablado en Argentina, por ejemplo, la palabra "cero" puede tener las siguientes transcripciones a fonemas respectivamente.
<code>CERO th e r o</code> o <code>CERO s e r o</code></p>

<p>Por lo tanto, el diccionario tendrá la siguiente pinta:</p>

<pre><code>CERO s e r o sp
CINCO s i n c o sp
CUATRO k u a t r o sp
DOS d o s sp
NUEVE n u e b e sp
OCHO o ch o sp
SEIS s e i s sp
SIETE s i e t e sp
TRES t r e s sp
UNO u n o sp
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Dictionary/DictionarySources/dict?at=master">Dictionary/DictionarySources/dict</a></p>

<h3>1.4. Grabando datos de entrenamiento</h3>

<p>Para poder entrenar nuestro sistema, se necesitan grabaciones de entrenamiento, la decisión sobre que datos de entrenamiento usar implican un mejor o peor desempeño en el reconocedor. Para esta prueba en particular, se grabaron 4 sets de entrenamiento (train1, train2, train3 y train4) en dónde cada uno contiene una grabación por cada dígito (de manera aislada, es decir, solo el dígito de comienzo a fin sin silencios). </p>

<p>Ejemplo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Data/Recorded/waves/train/train1/seis.wav?at=master">Data/Recorded/waves/train/train1/seis.wav</a></p>

<p>Para lograr compatibilidad con HTK, usaremos el siguiente formato para grabar (entre paréntesis indico donde encontrar la opción si utilizamos Audacity 2.0.3):</p>

<ul>
<li>Mono (Edit\Preferences\Devices) </li>
<li>16 kHz sampling frequency (Edit\Preferences\Quality\Sampling) </li>
<li>16 bits por sample (Edit\Preferences\Quality\Sampling) </li>
</ul><p>Por otro lado, cada uno de estos datos de entrenamiento necesitan una transcripción (.lab), esta transcripción debe contener los fonemas que se utilizan en la palabra grabada. </p>

<p>En vez de hacerlo manualmente, aprovecharemos un script que se encargará de facilitarnos ese trabajo, pero en caso de no tener este script, habría que construirlos manualmente con la pinta:</p>

<pre><code>0.0 0.5064375  o ch o
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Data/Train/train1-ocho.lab?at=master">Data/Train/train1-ocho.lab</a></p>

<p>El script que utilizaremos es <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Helpers/labels_from_wavs_script.rb?at=master">Helpers/labels_from_wavs_script.rb</a></p>

<pre><code>sudo gem install waveinfo
Helpers/labels_from_wavs_script.rb "Data/Recorded/waves/train/" "Data/Train/"
</code></pre>

<p>Este script escanea la carpeta de origen (Data/Recorded/waves/train) en búsqueda de subcarpetas que contengan wavs. Al encontrarlos, genera un archivo .lab por cada .wav (si no existe previamente en la carpeta de origen) y los guarda en el la carpeta de destino (segundo parametro) "Data/Train/" con el nombre "subcarpeta"-"nombre".lab (ejemplo el archivo train1-ocho.lab mostrado anteriormente).
Si existía un .lab en alguna de las subcarpetas del origen (ver <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Data/Recorded/waves/train/train5?at=master">train5</a> por ejemplo) el script copia estas transcripciones agregándoles en el nombre, el prefijo de la subcarpeta correspondiente. Se puede ver un ejemplo de este caso en <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Data/Train/train5-siete.lab?at=master">Data/Train/train5-siete</a>, notar que el .lab no fue generado automaticamente sino copiado de la carpeta train5. </p>

<h2>2. Combinando los datos</h2>

<p>En esta sección, nos concentraremos en dejar todo listo para empezar con el entrenamiento. Generaremos un diccionario y listado de fonemas, convertiremos la gramática a un formato estándar, crearemos Master Label Files, convertiremos el audio a su vector de features (MFCCs), y crearemos las carpetas necesarias para almacenar los distintos modelos que irán avanzando a medida que avance el entrenamiento. </p>

<h3>2.1. Diccionario y listado de fonemas</h3>

<p>Para generar el diccionario y listado de fonemas que utilizaremos más adelante, usaremos el comando HDMan de HTK: </p>

<pre><code>HDMan -m -w Dictionary/DictionarySources/words-sorted.list -n Dictionary/phones-with-sp.list -l dlog Dictionary/phones.dict Dictionary/DictionarySources/dict
</code></pre>

<p>Esto último, genera 2 archivos importantes: Dictionary/phones.dict y Dictionary/phones-with-sp.list, y por otro lado, un log (dlog) que sirve para ver cuantas repeticiones de los fonemas se utilizan. </p>

<p>Lo que ocurrió es que dict fue usado como origen para generar phones.dict, y solo se toma de él las palabras que aparecen en word-sorted.list. Es decir, sería totalmente posible tener un diccionario dict con muchas más traducciones (palabra a fonemas) como source. </p>

<p>Además, debemos agregar al diccionario <code>Dictionary/phones.dict</code> las siguientes lineas (manteniendo el orden alfabético)</p>

<pre><code>SENT-END [] sil
SENT-START [] sil
SILENCE sil
</code></pre>

<p>Quedando finalmente: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Dictionary/phones.dict?at=master">Dictionary/phones.dict</a></p>

<p>Y también, agregaremos al archivo <code>Dictionary/phones-with-sp.list</code>, las siguiente lineas </p>

<pre><code>sil
sp
</code></pre>

<p>Quedando finalmente: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Dictionary/phones-with-sp.list?at=master">Dictionary/phones-with-sp.list</a></p>

<p>Luego, debemos crear un nuevo archivo copiando Dictionary/phones-with-sp.list en el cual borremos la linea que contiene al fonema "sp", generando así el archivo <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Dictionary/phones.list?at=master">Dictionary/phones.list</a></p>

<h3>2.2. Gramática a WordNet</h3>

<p>HTK utiliza un formato especial para representar la gramática, es un "word network" (red de palabras), básicamente, es una notación de bajo nivel llamada "HTK Standard Lattice Format (SLF)" en el cual, cada instancia de palabra y cada transición entre palabras esta listado explicitamente. Podemos crear esta red automaticamente utilizando el comando</p>

<pre><code>HParse Dictionary/DictionarySources/grammar Dictionary/DictionarySources/grammar.wordnet 
</code></pre>

<p>Aclaración: Este comando es el único que no logré hacer funcionar en Mac OS X, así que opté por correrlo en Ubuntu donde no hubo problemas. </p>

<h3>2.3. Master label files (mlf)</h3>

<p>A continuación crearemos una version "naive" de un master label file, y digo "naive" porque no explota el verdadero poder de estos archivos, que permiten, entre otras cosas, una organización más inteligente de labels y grabaciones de entrenamiento. </p>

<p>Primero, crearemos el archivo "train-words.mlf"</p>

<pre><code>Helpers/generate_word_mlf_from_training.rb
</code></pre>

<p>Esto genera un archivo de la pinta</p>

<pre><code>#!MLF!#
"*/train1-cero.lab"
CERO
.
"*/train1-cinco.lab"
CINCO
.
"*/train1-cuatro.lab"
CUATRO
.
"*/train1-dos.lab"
DOS
.
"*/train1-uno.lab"
UNO
.
"*/train2-cero.lab"
CERO
.
"*/train2-cinco.lab"
CINCO
.
"*/train2-cuatro.lab"
...
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Data/train-words.mlf?at=master">Data/train-words.mlf</a></p>

<p>Luego asegurarse que cada elemento contenga la transcripción a nivel palabras de lo que cada .wav contiene (el script lo hace en base al nombre del archivo). </p>

<p>Luego debemos generar un archivo que contiene las transcripciones a nivel fonemas, para eso utilizaremos el comando <code>HLEd</code></p>

<p>Primero, generaremos un archivo de configuración con la siguiente pinta:</p>

<pre><code>EX
IS sil sil
DE sp

</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Configs/HLEd.config?at=master">Configs/HLEd.config</a></p>

<p>Y luego, el comando propiamente dicho: </p>

<pre><code>HLEd -l '*' -d Dictionary/phones.dict -i Data/train-phones.mlf Configs/HLEd.config Data/train-words.mlf
</code></pre>

<p>Que genera un archivo de la pinta:</p>

<pre><code>#!MLF!#
"’*’/train1-cero.lab"
sil
s
e
r
o
sil
.
"’*’/train1-cinco.lab"
sil
s
i
n
c
o
sil
.
"’*’/train1-cuatro.lab"
sil
k
u
a
t
r
o
sil
.
...
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Data/train-phones.mlf?at=master">Data/train-phones.mlf</a></p>

<h3>2.4. Mel Frequency Cepstral Coefficients (MFCCs)</h3>

<p>Para traducir los .wav al formato de features que utilizaremos (MFCCs), vamos a usar el comando <em>HCopy</em></p>

<p>Primero, necesitamos generar ciertos archivos llamados <em>scripts</em> en el manual de HTK, que constan, generalmente, de listados de archivos que los comandos luego recorrerán y tomarán como input. </p>

<p>Por ejemplo, antes de correr el comando HCopy, utilizaremos el siguiente comando</p>

<pre><code>Helpers/generate_hcopy_script.rb
</code></pre>

<p>Este comando, crea un archivo de la pinta:</p>

<pre><code>./Data/Recorded/waves/train/train1/cero.wav  ./Data/Train/train1-cero.mfc 
./Data/Recorded/waves/train/train1/cinco.wav  ./Data/Train/train1-cinco.mfc 
./Data/Recorded/waves/train/train1/cuatro.wav  ./Data/Train/train1-cuatro.mfc 
./Data/Recorded/waves/train/train1/dos.wav  ./Data/Train/train1-dos.mfc 
./Data/Recorded/waves/train/train1/nueve.wav  ./Data/Train/train1-nueve.mfc 
./Data/Recorded/waves/train/train1/ocho.wav  ./Data/Train/train1-ocho.mfc 
./Data/Recorded/waves/train/train1/seis.wav  ./Data/Train/train1-seis.mfc 
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Scripts/HCopy.script?at=master">Scripts/HCopy.script</a></p>

<p>Luego, necesitamos generar el archivo de configuración HCopy.config</p>

<pre><code># Coding parameters
SOURCEKIND = WAVEFORM
SOURCEFORMAT = WAV
TARGETKIND = MFCC_0
TARGETRATE = 100000.0
SAVECOMPRESSED = T
SAVEWITHCRC = T
WINDOWSIZE = 250000.0
USEHAMMING = T
PREEMCOEF = 0.97
NUMCHANS = 26
CEPLIFTER = 22
NUMCEPS = 12
ENORMALISE = F

</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Configs/HCopy.config?at=master">Configs/HCopy.config</a></p>

<p>Finalmente, podemos correr HCopy para traducir de wavs a mfccs: </p>

<pre><code>HCopy -T 1 -C Configs/HCopy.config -S Scripts/HCopy.script
</code></pre>

<p>Si todo salió bien, deberíamos tener la carpeta <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Data/Train?at=master">Data/Train</a> lleno de archivos .mfc (uno por cada grabación de entrenamiento)</p>

<h3>2.5. Generación de un modelo prototípico</h3>

<p>Para lograr entrenar nuestro modelo, debemos partir de un modelo base que luego varíe hasta convertirse en el HMM final que utilizaremos para reconocer palabras. Este paso lo lograremos creando un modelo en Models/hmm0. </p>

<p>Lo primero que hay que hacer es crear un nuevo archivo que contenga lo siguiente:</p>

<pre><code>  ~o &lt;VecSize&gt; 39 &lt;MFCC_0_D_A&gt;  
  ~h "prototype"
&lt;BeginHMM&gt;
  &lt;NumStates&gt; 5
  &lt;State&gt; 2 
    &lt;Mean&gt; 39
      0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
    &lt;Variance&gt; 39
      1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
  &lt;State&gt; 3
    &lt;Mean&gt; 39
      0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
    &lt;Variance&gt; 39
      1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
  &lt;State&gt; 4
    &lt;Mean&gt; 39
      0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 
    &lt;Variance&gt; 39
      1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0 1.0
  &lt;TransP&gt; 5
   0.000e+0   1.000e+0   0.000e+0   0.000e+0   0.000e+0
   0.000e+0   6.000e-1   4.000e-1   0.000e+0   0.000e+0
   0.000e+0   0.000e+0   6.000e-1   4.000e-1   0.000e+0
   0.000e+0   0.000e+0   0.000e+0   6.000e-1   4.000e-1
   0.000e+0   0.000e+0   0.000e+0   0.000e+0   0.000e+0
&lt;EndHMM&gt;

</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Models/prototype?at=master">Models/prototype</a></p>

<p>Luego, necesitamos un archivo de configuración para el comando que utilizaremos:</p>

<pre><code># Coding parameters
SOURCEFORMAT = HTK
TARGETKIND = MFCC_0_D_A
TARGETRATE = 100000.0
SAVECOMPRESSED = T
SAVEWITHCRC = T
WINDOWSIZE = 250000.0
USEHAMMING = T
PREEMCOEF = 0.97
NUMCHANS = 26
CEPLIFTER = 22
NUMCEPS = 12
ENORMALISE = F

</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Config/HCompV.config?at=master">Configs/HCompV.config</a></p>

<p>Y un listado correspondiente para este archivo</p>

<pre><code>Helpers/generate_hcompv_script.rb
</code></pre>

<p>Que genera algo como: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Scripts/HCompV.script?at=master">Scripts/HCompV.script</a></p>

<p>Ahora si, podemos utilizar el comando para crear nuestro primer modelo entrenado a partir de los datos</p>

<pre><code>HCompV -C Configs/HCompV.config -f 0.01 -m -S Scripts/HCompV.script -M Models/hmm0 Models/prototype
</code></pre>

<p>Esto genera 2 archivos <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Models/hmm0/prototype?at=master">Models/hmm0/prototype</a> y <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Models/hmm0/vFloors?at=master">Models/hmm0/vFloors</a> que nos serán utiles en el próximo paso.</p>

<h3>2.6. Generación del primer modelo</h3>

<p>Una vez que tenemos los archivos <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Models/hmm0/prototype?at=master">Models/hmm0/prototype</a> y <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Models/hmm0/vFloors?at=master">Models/hmm0/vFloors</a>, generaremos un nuevo archivo que contenga, una copia del prototipo por cada fonema utilizado (sin sp).</p>

<p>Para lograrlo, podemos utilizar el script de bash: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Helpers/create_hmm_defs.sh?at=master">Helpers/create_hmm_defs.sh</a></p>

  <pre><code>Helpers/create_hmm_defs.sh</pre></code>


<p>Que lo que hace es distribuir el prototipo para cada fonema. Por ejemplo, si el prototipo tiene la forma </p>

<pre><code>  ~o &lt;VecSize&gt; 39 &lt;MFCC_0_D_A&gt;  
  ~h "prototype"
&lt;BeginHMM&gt;
  &lt;NumStates&gt; 5
  &lt;State&gt; 2 
  ...
&lt;EndHMM&gt;
</code></pre>

<p>Donde llamaré HMMPrototipo a lo que esta entre &lt;BeginHMM&gt; y &lt;EndHMM&gt; incluyendo estas etiquetas</p>

<p>Creará otro archivo que contenga este modelo por cada fonema que encontremos en el archivo <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Dictionary/phones.list?at=master">Dictionary/phones.list</a>:</p>

<pre><code>~h "c"
HMMPrototipo
~h "e"
HMMPrototipo
...
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Models/hmm0/hmmdefs?at=master">Models/hmm0/hmmdefs</a></p>

<p>Finalmente, copiaremos el archivo Models/hmm0/vFloors a uno nuevo llamado macro agregando el siguiente header: </p>

<pre><code>~o
&lt;STREAMINFO&gt; 1 39
&lt;VECSIZE&gt; 39&lt;NULLD&gt;&lt;MFCC_D_A_0&gt;&lt;DIAGC&gt;
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Models/hmm0/macros?at=master">Models/hmm0/macros</a></p>

<h2>3. Entrenamiento del modelo</h2>

<h3>3.1. Hmm1 - Hmm3</h3>

<p>Ahora si, ya tenemos un modelo prototípico del cual partir. Como hicimos anteriormente, generamos el listado necesario para el comando que utilizaremos, en este caso, HERest</p>

<pre><code>Helpers/generate_herest_script.rb
</code></pre>

<p>Ahora, re-estimaremos el modelo usando la herramienta para "embedded re-estimation" HERest</p>

<pre><code>HERest -T 1 -C Configs/HERest.config -I Data/train-phones.mlf -t 1000.0 1000.0 10000.0 -S Scripts/HERest.script -H Models/hmm0/macros -H Models/hmm0/hmmdefs -M Models/hmm1 Dictionary/phones.list
HERest -T 1 -C Configs/HERest.config -I Data/train-phones.mlf -t 1000.0 1000.0 10000.0 -S Scripts/HERest.script -H Models/hmm1/macros -H Models/hmm1/hmmdefs -M Models/hmm2 Dictionary/phones.list
HERest -T 1 -C Configs/HERest.config -I Data/train-phones.mlf -t 1000.0 1000.0 10000.0 -S Scripts/HERest.script -H Models/hmm2/macros -H Models/hmm2/hmmdefs -M Models/hmm3 Dictionary/phones.list
</code></pre>

<h3>3.2. Hmm4 - Hmm7</h3>

<p>En este paso, debemos agregar el estado "sp" en una copia de hmmdefs de hmm3 y guardarlo en hmm4. Para agregar el estado, hacer lo siguiente:
<a href="http://www.voxforge.org/home/dev/acousticmodels/linux/create/htkjulius/tutorial/monophones/step-7">agregar sp</a></p>

<p>Luego del reemplazo, corremos:</p>

<pre><code>HHEd -A -D -T 1 -H Models/hmm4/macros -H Models/hmm4/hmmdefs -M Models/hmm5 Configs/HHEd.config Dictionary/phones-with-sp.list
</code></pre>

<p>Cuando se agrego el nuevo estado, seguimos re-estimando con:</p>

<pre><code>HERest -T 1 -C Configs/HERest.config -I Data/train-phones.mlf -t 1000.0 1000.0 10000.0 -S Scripts/HERest.script -H Models/hmm5/macros -H Models/hmm5/hmmdefs -M Models/hmm6 Dictionary/phones-with-sp.list
HERest -T 1 -C Configs/HERest.config -I Data/train-phones.mlf -t 1000.0 1000.0 10000.0 -S Scripts/HERest.script -H Models/hmm6/macros -H Models/hmm6/hmmdefs -M Models/hmm7 Dictionary/phones-with-sp.list
</code></pre>

<p><strong>Hasta aquí</strong> llegará el entrenamiento, sin embargo, en el tutorial de HTK existen más pasos que permiten seguir entrenando el modelo para conseguir mejor performance. </p>

<h2>4. Resultados</h2>

<h3>4.1. Grabar datos para testear</h3>

<p>De la misma forma que grabamos los datos de entrenamiento (mismo formato sobre todo) grabaremos casos de prueba en la carpeta [Data/Recorded/waves/train], estos datos no necesitan transcripción, ya que esa será la salida de nuestro programa.</p>

<h3>4.2. Generar vectores MFCC</h3>

<p>Primero, debemos, al igual que con los datos de entrenamiento, listar los archivos de test que poseemos:</p>

<pre><code>Helpers/generate_hcopy_tests_script.rb 
</code></pre>

<p>Que genera un archivo de la pinta</p>

<pre><code>./Data/Recorded/waves/tests/0.wav ./Data/Test/0.mfc
./Data/Recorded/waves/tests/9.wav ./Data/Test/9.mfc
./Data/Recorded/waves/tests/12151516790.wav ./Data/Test/12151516790.mfc
./Data/Recorded/waves/tests/64.wav ./Data/Test/64.mfc
./Data/Recorded/waves/tests/111111111.wav ./Data/Test/111111111.mfc
...
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Scripts/HCopyTests.script?at=master">Scripts/HCopyTests.script</a></p>

<p>Luego, generar el archivo de configuración:</p>

<pre><code># Coding parameters
SOURCEKIND     = WAVEFORM
SOURCEFORMAT = WAV
TARGETKIND = MFCC_0_D_A
TARGETRATE = 100000.0
SAVECOMPRESSED = T
SAVEWITHCRC = T
WINDOWSIZE = 250000.0
USEHAMMING = T
PREEMCOEF = 0.97
NUMCHANS = 26
CEPLIFTER = 22
NUMCEPS = 12
ENORMALISE = F
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Configs/HCopyTests.config?at=master">Configs/HCopyTests.config</a></p>

<p>Y finalmente, los MFCCs a partir de los wavs:</p>

<pre><code>HCopy -T 1 -C Configs/HCopyTests.config -S Scripts/HCopyTests.script
</code></pre>

<h3>4.3. Obtención de resultados</h3>

<p>Para testear contra el modelo entrenado, utilizaremos el comando <code>HVite</code>, para lo cual necesitamos el listado de archivos de entrenamiento:</p>

<pre><code>Helpers/generate_hvite_script.rb 
</code></pre>

<p>Este comando, crea un archivo de la pinta:</p>

<pre><code>./Data/Test/0.mfc
./Data/Tests/1.mfc
./Data/Tests/111111111.mfc
./Data/Tests/12151516790.mfc
...
</code></pre>

<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/Scripts/HVite.script?at=master">Scripts/HVite.script</a></p>

<p>Y finalmente: </p>

<pre><code>HVite -H Models/hmm7/macros -H Models/hmm7/hmmdefs -S Scripts/HVite.script -l ’*’ -i recout.mlf -w Dictionary/DictionarySources/grammar.wordnet -p 0.0 -s 5.0 Dictionary/phones.dict Dictionary/phones-with-sp.list
</code></pre>

<p>Que genera un archivo llamado recout.mlf que contiene los resultados de las pruebas en formato MLF.</p>

<p>Veamos que resultados obtenemos con nuestras pruebas: </p>

<pre><code>
#!MLF!#
"’*’/0.rec"
200000 5000000 CERO -3726.999512
.
"’*’/1.rec"
200000 3700000 NUEVE -2706.457031
.
"’*’/111111111.rec"
4900000 8700000 UNO -3047.186523
8700000 9600000 SILENCE -687.649902
9600000 13400000 SILENCE -2803.908936
13400000 17100000 UNO -3049.597900
17100000 22700000 SILENCE -4086.941162
22700000 26500000 UNO -3076.622070
26500000 32700000 SILENCE -4540.036133
32700000 37200000 UNO -4114.881836
37200000 41000000 SILENCE -2687.449219
41000000 45200000 UNO -3496.323730
45200000 50300000 SILENCE -3831.360840
50300000 54400000 UNO -3357.770752
54400000 59500000 SILENCE -3710.324951
59500000 62000000 UNO -2093.911133
62000000 69600000 SEIS -5990.604980
69600000 73000000 UNO -2787.947021
73000000 78600000 SILENCE -4330.362305
78600000 81500000 UNO -2381.184326
81500000 85800000 SILENCE -2987.628418
85800000 90500000 SEIS -3570.850098
.
"’*’/12151516790.rec"
200000 7000000 SEIS -5451.008789
7000000 14600000 NUEVE -5997.730957
14600000 22500000 DOS -6012.020508
22500000 23000000 SILENCE -411.934204
23000000 26800000 UNO -3200.117920
26800000 28800000 SILENCE -1459.994995
28800000 35200000 SEIS -5432.436035
35200000 36100000 SILENCE -620.031921
36100000 39700000 SEIS -2792.967529
39700000 43100000 NUEVE -2811.309570
43100000 45800000 SILENCE -1849.160278
45800000 51100000 SIETE -4253.234863
51100000 53900000 SILENCE -1998.492310
53900000 59200000 SEIS -4591.272949
59200000 61300000 SILENCE -1497.800781
61300000 67300000 CINCO -4404.187500
67300000 68500000 SILENCE -834.470337
68500000 74400000 SEIS -5168.071289
74400000 78400000 SILENCE -2983.903076
.
"’*’/2.rec"
200000 4600000 DOS -3542.130371
.
"’*’/3.rec"
200000 4200000 TRES -2939.333252
.
"’*’/4.rec"
200000 4500000 OCHO -3824.226562
.
"’*’/5.rec"
200000 6200000 CERO -4815.431152
.
"’*’/6.rec"
200000 5500000 SIETE -4075.147461
.
"’*’/64.rec"
200000 6300000 SEIS -4957.386719
6300000 11400000 TRES -3638.761963
11400000 12800000 SILENCE -983.018127
12800000 19200000 SEIS -5460.396484
19200000 25600000 SEIS -5414.715820
.
"’*’/7.rec"
200000 5700000 SEIS -4419.517090
.
"’*’/8.rec"
200000 4700000 OCHO -3495.556885
.
"’*’/9.rec"
200000 5800000 UNO -3856.241699
.
"’*’/test1-12151516790.rec"
200000 7000000 SEIS -5451.008789
7000000 14600000 NUEVE -5997.730957
14600000 22500000 DOS -6012.020508
22500000 23000000 SILENCE -411.934204
23000000 26800000 UNO -3200.117920
26800000 28800000 SILENCE -1459.994995
28800000 35200000 SEIS -5432.436035
35200000 36100000 SILENCE -620.031921
36100000 39700000 SEIS -2792.967529
39700000 43100000 NUEVE -2811.309570
43100000 45800000 SILENCE -1849.160278
45800000 51100000 SIETE -4253.234863
51100000 53900000 SILENCE -1998.492310
53900000 59200000 SEIS -4591.272949
59200000 61300000 SILENCE -1497.800781
61300000 67300000 CINCO -4404.187500
67300000 68500000 SILENCE -834.470337
68500000 74400000 SEIS -5168.071289
74400000 78400000 SILENCE -2983.903076
.
"’*’/test2-64.rec"
200000 6300000 SEIS -4957.386719
6300000 11400000 TRES -3638.761963
11400000 12800000 SILENCE -983.018127
12800000 19200000 SEIS -5460.396484
19200000 25600000 SEIS -5414.715820
.
"’*’/test3-4.rec"
300000 5600000 SEIS -4878.258301
.
"’*’/test4-111111111.rec"
4900000 8700000 UNO -3047.186523
8700000 9600000 SILENCE -687.649902
9600000 13400000 SILENCE -2803.908936
13400000 17100000 UNO -3049.597900
17100000 22700000 SILENCE -4086.941162
22700000 26500000 UNO -3076.622070
26500000 32700000 SILENCE -4540.036133
32700000 37200000 UNO -4114.881836
37200000 41000000 SILENCE -2687.449219
41000000 45200000 UNO -3496.323730
45200000 50300000 SILENCE -3831.360840
50300000 54400000 UNO -3357.770752
54400000 59500000 SILENCE -3710.324951
59500000 62000000 UNO -2093.911133
62000000 69600000 SEIS -5990.604980
69600000 73000000 UNO -2787.947021
73000000 78600000 SILENCE -4330.362305
78600000 81500000 UNO -2381.184326
81500000 85800000 SILENCE -2987.628418
85800000 90500000 SEIS -3570.850098
.

</code></pre>
<p>Nombre del archivo: <a href="https://bitbucket.org/pbrusco/tesis-proyectos/src/master/Spikes/digitos/recout.mlf?at=master">recout.mlf</a></p>

<p>Podrás mejorarlo? :)</p>

<h2>Preguntas? Comentarios?</h2>

<p>Ante cualquier duda o comentario, enviar un email a <a href="mailto:pbrusco@manas.com.ar">pbrusco@manas.com.ar</a> o <a href="mailto:pablo.brusco@gmail.com">pablo.brusco@gmail.com</a></p>

<p>Gracias!</p>
<div class="fb-like" data-href="http://man.as/htk-tutorial" data-send="true" data-width="450" data-show-faces="true"></div>
      </section>

    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

    

  </body>
</html>
